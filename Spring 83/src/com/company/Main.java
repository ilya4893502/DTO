package com.company;

import java.io.PrintWriter;

public class Main {

    // DTO (Data Transfer Object).

    // На предыдущем уроке.
    // У нас был клиент, с помощью POST-запроса мы посылали JSON на сервер. На сервере мы парсили JSON в
    // Person.

    // В реальных проектах.
    // Между моделью и JSON есть еще слой DTO.


    // DTO (Data Transfer Object) - Объект для Передачи Данных.
    // - Это обычный Java-класс (даже может быть без аннотации @Component или @Entity). Объект этого класса
    // и есть DTO.
    // - Используется на уровне контроллера (глубже обчыно мы его не передаем). Например, в сервисе его не
    // используем.
    // - Может использоваться как для запросов, так и для ответов.
    // - Для запросов: клиент присылает JSON и мы его конвертируем в DTO.
    // - Для ответов: конвертируем объект модели в DTO и отправляем его клиенту.


    // Зачем нужен DTO?

    // Модель - это бизнес-логика. И использовать эту сущность, которая отображает бизнес-логику для отправки
    // данных между клиентом и сервером неправильно. Потому что модель может отличаться от того, что приходит
    // от клиента при создании или того, что мы хотим отправлять клиенту (разный набор полей).

    // DTO - объект для передачи данных.

    // Модель и DTO могут полностью совпадать - такое тоже часто бывает. Но DTO все равно используют даже в
    // этом случае, потому что это облегчает дальнейшие изменения. Это хороший стиль программирования -
    // разделять модель и объект для передачи данных.
    // Благодаря этому, в будущем мы сможем менять отдельно модель - при этом не будет меняться то, что мы
    // отдаем клиенту или принимаем от клиента, и отдельно менять DTO - при этом не будет меняться модель.


    // Примеры использования DTO.

    // - В модели есть поля, которые на назначаются данными от клиента (то же поле id, например - клиенту не
    // нужно его назначать, но он будет его получать). В модели id будет, а в DTO нет.

    // - В модели не нужны все поля, которые приходят от клиента. Если мы хотим проверять пароль и
    // подтверждение пароля на сервере, то в DTO будет два этих поля, но в модели хранится только сам пароль.
    // Подтверждение хранится только в DTO.

    // - Хотим отправлять клиенту какие-то дополнительные поля, например, уникальный токен в ответ. К бизнес
    // логике этот токен не относится (в модели его нет), помещаем его в DTO.




    // Практика.

    // Добавим в таблицу Person колонки created_at и updated_at типа timestamp, в которой будет храниться
    // время создания и обновления человека. Также колонка created_who, в которой указано кто обновлял.
    // alter table person add column created_at timestamp,
    //     add column updated_at timestamp,
    //     add column created_who varchar;

    // Соответствующим образом обновим модель Person.

    // Так как есть разница между моделью и приходящим объектом создадим DTO.

    // Далее перейдем в контроллер. Так как DTO работает на уровне контроллера, не глубже.


    // Запустим, при сохранении человека все работает.
    // Мы назначили только 3 поля, указанные в DTO, остальные назначил сервис.


    // Чтобы автоматизировать назначение полей при конвертации DTO и модели используем аннотацию @ModelMapper.
    // Добавим зависимость ModelMapper в pom.xml.
}

